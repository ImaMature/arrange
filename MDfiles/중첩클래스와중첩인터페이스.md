## 중첩 클래스
>**멤버 클래스** 
>  
>클래스의 멤버로서 선언되는 중첩 클래스   
>클래스나 객체가 사용 중이라면 언제든지 재사용이 가능하다. 
> 
>**로컬 클래스**  
>  
>메소드 내부에서 선언되는 중첩 클래스   
>메소드 실행 시에만 사용되고, 메소드가 실행 종료되면 없어진다.

![image](https://user-images.githubusercontent.com/88884623/140924776-846b318e-c6c2-41e0-b8bc-7b989089fafc.png)   


## 인스턴스 멤버 클래스
> static 키워드 없이 선언된 클래스를 일컫는다.   
> 인스턴스 필드와 메소드만 선언 가능하고 정적 필드와 메소드는 선언할 수 없다.
> ```java
> class A {
> //인스턴스 멤버 클래스//
>   class B {
>   B() { }     //생성자
>   int field1; //인스턴스 필드
>   //static int field2;        //정적 필드라서 선언 불가
>   void method1() { }          //인스턴스 메소드
>   //static void method2() { } //정적 메소드라서 선언 불가
> ```
> ```java
> //A 클래스 외부에서 인스턴스 멤버 클래스 B의 객체를 생성하려면 먼저 A객체를 생성하고 B객체를 생성해야 한다.
>
>A a = new A();
>A.B b = a.new B();   //B클래스의 생성자B를 a에 저장해서 A클래스의 B클래스 호출해서 b선언과 동시에 저장
>b.field1 = 3;
>b.method1();
> ```

## 로컬 클래스
>접근 제한자 및 static을 붙일 수 없다.
>메소드 내부에서만 사용되므로 접근을 제한할 필요가 없기 때문
>로컬 클래스 내부에서는 인스턴스 필드와 메소드만 선언이 가능하다.
>
>``` java
>void method()
>   \\\로컬 클래스\\\  
>   class D {           
>   D() { }                       //생성자
>   int field1;                   //인스턴스 필드
>     //static int field2;        //정적 필드(X)
>   void method1() { }            //인스턴스 메소드
>     //static void method2();    //정적 메소드(X)
>   }
>   D d = new D();
>   d.field = 3;
>   d.method1();    
>```
>
>또한, 로컬 클래스는 메소드가 실행될 때 메소드 내에서 객체를 생성하고 사용해야 한다.
>주로 비동기 처리를 위해 스레드 객체를 만들 때 사용한다.

## 중첩 클래스의 접근 제한
**바깥 필드와 메소드에서 사용 제한**   
>멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라 바깥 클래스의 필드와 메소드에 사용 제한이 생긴다.
>     
>![image](https://user-images.githubusercontent.com/88884623/140928875-f6fe733e-57f4-4710-9fde-08b289aecd02.png)    
>  
>정적 (static) 멤버 클래스는 인스턴스 필드와 메소드에는 접근이 불가능하다   

**멤버 클래스에서 사용 제한**   
>멤버 클래스가 인스턴스 도는 정적으로 선언됨에 따라 멤버 클래스 내부에서 바깥 클래스의 필드와 메소드를 접근할 때에도 제한이 생긴다.  
>   
>![image](https://user-images.githubusercontent.com/88884623/140929299-1f32dd5b-b75b-4ce2-b805-2346513a6af0.png)   
  
   
**멤버 클래스에서 사용 제한** 
  
>로컬 클래스 내부에서는 바깥 클래스의 필드나 메소드를 제한 없이 사용할 수 있다.   
>  
>문제는 메소드의 *매개 변수*나 *로컬 변수*를 로컬 클래스에서 사용할 때이다.
>
>로컬 클래스의 객체는 메소드 실행이 끝나도 힙 메모리에 존재해서 계속 사용될 수 있다.
>
>매개 변수나 로컬 변수는 메소드 실행이 끝나면 스택 메모리에서 사라져서 로컬 객체에서 사용할 경우 문제가 생긴다.
>
>자바는 컴파일 시 이러한 값들을 로컬 클래스 내부에 복사해 두고 사용한다.
>
>final로 선언해서 수정을 막아서 매개 변수나 로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해 둔 값과 달라지는 문제를 해결한다. 
>
>자바 8 이후 로컬 클래스에서 사용된 매개 변수와 로컬 변수는 final이 붙어있지 않지만 모두 final 특성을 같는다.

## 중첩 클래스에서 바깥 클래스 참조 얻기
>클래스 내부에서 this는 객체 자신의 참조이다.
>
>중첩 클래스에서 this를 사용하면 바깥 클래스의 객체 참조가 아니라, 중첩 클래스의 객체 참조가 된다.
> 
>중첩 클래스 내부에서 바깥 클래스의 객체 참조를 얻으려면 바깥 클래스의 이름을 this 앞에 붙여줘야 한다.
```java
바깥클래스.this.필드
바깥클래스.this.메소드();
```
>

## 익명 객체
>익명 객체는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이슬 구현해야만 생성할 수 있다.
>
>익명 객체는 필드, 매개변수, 로컬 변수의 초기값으로 주로 사용된다.
>
>익명 객체에는 생성자를 선언할 수 없다.
>
>부모 클래스나 인터페이스에 선언된 필드와 메소드 이외에 다른 필드와 메소드를 선언할 수 있지만, 익명 객체 내부에서만 사용이 가능하다.
>
>부모 클래스를 상속해서 자식 클래스를 선언하고, new 연산자를 이용해서 자식 객체를 생성한 후, 필드나 로컬 변수에 대입하는 것이 기본.
>
>``` java
>부모클래스 [필드나 변수] = new 부모클래스(매개값1, 2...) {
>   //필드
>   //메소드
>}
>```
>
>부모클래스 (매개값, ...) {} 은 부모 클래스를 상속해서 중괄호 {}와 같이 자식클래스를 선언하라는 뜻
>
>new 연산자는 이렇게 선언된 자식 클래스를 객체로 생성한다.
>
>부모 클래스 (매개값, ...)은 부모 생성자를 호출하는 코드로, 매개 값은 부모 생성자의 매개 변수에 맞게 입력하면 된다.

## 익명 구현 객체 생성
> 구현 클래스를 선언하고, new 연산자를 이용해서 구현 객체를 생성한 후, 필드나 로컬 변수에 대입하는 것이 기본
> ``` java
> class TV implements RemoteControl { }
>
> class A {
>   RemoteControl field = new TV();         //필드에 구현 객체를 대입
>   void method() {
>     RemoteControl localvar = new TV();    //로컬 변수에 구현 객체를 대입
>   }
> }     
> ```
